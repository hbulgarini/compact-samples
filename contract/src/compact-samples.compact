// This file is part of midnightntwrk/example-counter.
// Copyright (C) 2025 Midnight Foundation
// SPDX-License-Identifier: Apache-2.0
// Licensed under the Apache License, Version 2.0 (the "License");
// You may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

pragma language_version 0.16;

import CompactStandardLibrary;

 export struct UserData {
    name: Opaque<"string">;
    email: Opaque<"string">;
    birthDate: Opaque<"string">;
    userId: Field;
    isValid: Boolean;
}

export struct StructExample {
    field1: Field;
    field2: Field;
    field3: Field;
}

export ledger simpleMap: Map<Field, Field>;
export ledger simpleMapString: Map<Field, Opaque<"string">>;
export ledger simpleMapEncryptedString: Map<Field, Bytes<32>>;
export ledger structMapExample: Map<Bytes<32>, UserData>;
export ledger simpleNestedMap: Map<Field, Map<Field, Field>>;
export ledger structNestedMap: Map<Field, Map<Field, StructExample>>;


export circuit addStructNestedFieldItem(key1: Field, key2: Field, value: StructExample): [] {
    const disclosedKey2 = disclose(key2);
    const disclosedValue = disclose(value);
    structNestedMap.lookup(key1).insert(disclosedKey2, disclosedValue);
} 

export circuit addFieldItem(key: Field, value: Field): [] {
    const disclosedKey = disclose(key);
    const disclosedValue = disclose(value);
    simpleMap.insert(disclosedKey, disclosedValue);
}

export circuit addNestedFieldItem(key1: Field, key2: Field, value: Field): [] {
    const disclosedKey1 = disclose(key1);
    const disclosedKey2 = disclose(key2);
    const disclosedValue = disclose(value);
    // is this inserting the key1 if it does not exist?
    simpleNestedMap.lookup(disclosedKey1).insert(disclosedKey2, disclosedValue);
}


export circuit addStructItem(key: Bytes<32>, value: UserData): [] {
    const disclosedKey = disclose(key);
    const disclosedValue = disclose(value);
    structMapExample.insert(disclosedKey, disclosedValue);
}

export circuit addStringItem(key: Field, value: Opaque<"string">): [] {
    const disclosedKey = disclose(key);
    const disclosedValue = disclose(value);
    simpleMapString.insert(disclosedKey, disclosedValue);
}

export circuit addEncryptedItem(key: Field, userData: UserData): [] {
    const hashedValue = userHash(userData);
    /*
    This fails with the error:

      circuit "add_encrypted_item" |
        thread 'main' panicked at /sources/halo2_proofs-0.3.0-04db20e/src/plonk/keygen.rs:242:10:
        A circuit which can be implemented with at most 2^24 rows.
    */
//    simpleMapEncryptedString.insert(key, hashedValue);
}

export circuit userHash(user: UserData): Bytes<32> {
    return persistentHash<Vector<3, Opaque<"string">>>([user.name, user.email, user.birthDate]);
}

export circuit addEncryptedExample(key: Field, example: StructExample): [] {
    const hashedValue = exampleHash(example);
    simpleMapEncryptedString.insert(disclose(key), disclose(hashedValue)); // alternative pattern with less variables.
}

export circuit exampleHash(example: StructExample): Bytes<32> {
    return persistentHash<Vector<3, Field>>([example.field1, example.field2, example.field3]);
}